# harmony  [![Coverage Status](https://coveralls.io/repos/github/butuzov/harmony/badge.svg?t=1njyDt)](https://coveralls.io/github/butuzov/harmony) [![build status](https://github.com/butuzov/harmony/actions/workflows/main.yaml/badge.svg?branch=main)]() [![MIT License](http://img.shields.io/badge/license-MIT-blue.svg)](http://www.opensource.org/licenses/MIT)

Generic Concurrency Patterns Library

## Reference (generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>))

<!-- You can Edit Content above this comment --->
<!-- Start --->
```go
import "github.com/butuzov/harmony"
```

Package `harmony` provides generic concurrency patterns library, created for educational proposes by it's author. It provides next patterns: 
- `Bridge` 
- `FanIn` 
- `Feature` 
- `OrWithDone` / `OrWithDone` 
- `Pipeline` 
- `Queue` 
- `Tee` 
- `WorkerPool`

Code generated by cmd/internal/gendone. DO NOT EDIT.n

### Index

- [func BridgeWithContext[T any](ctx context.Context, incoming <-chan (<-chan T)) <-chan T](<#func-bridgewithcontext>)
- [func BridgeWithDone[T any](done <-chan struct{}, incoming <-chan (<-chan T)) <-chan T](<#func-bridgewithdone>)
- [func FanInWithContext[T any](ctx context.Context, ch1, ch2 <-chan T, channels ...<-chan T) <-chan T](<#func-faninwithcontext>)
- [func FanInWithDone[T any](done <-chan struct{}, ch1, ch2 <-chan T, channels ...<-chan T) <-chan T](<#func-faninwithdone>)
- [func FututeWithContext[T any](ctx context.Context, futureFn func() T) <-chan T](<#func-fututewithcontext>)
- [func FututeWithDone[T any](done <-chan struct{}, futureFn func() T) <-chan T](<#func-fututewithdone>)
- [func OrWithContext[T any](ctx context.Context, incoming <-chan T) <-chan T](<#func-orwithcontext>)
- [func OrWithDone[T any](done <-chan struct{}, incoming <-chan T) <-chan T](<#func-orwithdone>)
- [func PipelineWithContext[T any](ctx context.Context, incoming <-chan T, totalWorkers int, workerFn func(T) T) <-chan T](<#func-pipelinewithcontext>)
- [func PipelineWithDone[T any](done <-chan struct{}, incoming <-chan T, totalWorkers int, workerFn func(T) T) <-chan T](<#func-pipelinewithdone>)
- [func QueueWithContext[T any](ctx context.Context, genFn func() T) <-chan T](<#func-queuewithcontext>)
- [func QueueWithDone[T any](done <-chan struct{}, genFn func() T) <-chan T](<#func-queuewithdone>)
- [func TeeWithContext[T any](ctx context.Context, incoming <-chan T) (<-chan T, <-chan T)](<#func-teewithcontext>)
- [func TeeWithDone[T any](done <-chan struct{}, incoming <-chan T) (<-chan T, <-chan T)](<#func-teewithdone>)
- [func WorkerPoolWithContext[T any](ctx context.Context, totalWorkers int, workerFn func(T)) chan<- T](<#func-workerpoolwithcontext>)
- [func WorkerPoolWithDone[T any](done <-chan struct{}, totalWorkers int, workerFn func(T)) chan<- T](<#func-workerpoolwithdone>)


### func BridgeWithContext

```go
func BridgeWithContext[T any](ctx context.Context, incoming <-chan (<-chan T)) <-chan T
```

BridgeWithContext will return chan of generic type `T` used a pipe for the values received from the sequence of channels. Close channel .received from `incoming`. in order to  switch for a new one. Goroutines exists on close of `incoming` or context canceled.

### func BridgeWithDone

```go
func BridgeWithDone[T any](done <-chan struct{}, incoming <-chan (<-chan T)) <-chan T
```

BridgeWithDone will return chan of generic type `T` used a pipe for the values received from the sequence of channels. Close channel .received from `incoming`. in order to  switch for a new one. Goroutines exists on close of `incoming` or done chan closed.

### func FanInWithContext

```go
func FanInWithContext[T any](ctx context.Context, ch1, ch2 <-chan T, channels ...<-chan T) <-chan T
```

FanInWithContext returns unbuffered channel of generic type `T` which serves as delivery pipeline for the values received from at least 2 incoming channels, its closed once all of the incoming channels closed or context cancelled.

### func FanInWithDone

```go
func FanInWithDone[T any](done <-chan struct{}, ch1, ch2 <-chan T, channels ...<-chan T) <-chan T
```

FanInWithDone returns unbuffered channel of generic type `T` which serves as delivery pipeline for the values received from at least 2 incoming channels, its closed once all of the incoming channels closed or context cancelled.

### func FututeWithContext

```go
func FututeWithContext[T any](ctx context.Context, futureFn func() T) <-chan T
```

FututeWithContext.T any. will return buffered channel of size 1 and generic type `T`, which will eventually contain the results of the execution `futureFn``, or be closed in case if context cancelled.

### func FututeWithDone

```go
func FututeWithDone[T any](done <-chan struct{}, futureFn func() T) <-chan T
```

FututeWithDone.T any. will return buffered channel of size 1 and generic type `T`, which will eventually contain the results of the execution `futureFn``, or be closed in case if context cancelled.

### func OrWithContext

```go
func OrWithContext[T any](ctx context.Context, incoming <-chan T) <-chan T
```

OrWithDone will return a new unbuffered channel of type `T` that serves as a pipeline for the incoming channel. Channel is closed once the context is canceled or the incoming channel is closed. This is variation or the pattern that usually called `OrWithDone` or`Cancel`.

### func OrWithDone

```go
func OrWithDone[T any](done <-chan struct{}, incoming <-chan T) <-chan T
```

OrWithDone will return a new unbuffered channel of type `T` that serves as a pipeline for the incoming channel. Channel is closed once the context is canceled or the incoming channel is closed. This is variation or the pattern that usually called `OrWithDone` or`Cancel`.

### func PipelineWithContext

```go
func PipelineWithContext[T any](ctx context.Context, incoming <-chan T, totalWorkers int, workerFn func(T) T) <-chan T
```

PipelineWithContext returns the channel of generic type `T` that can serve as a pipeline for the next stage. It's implemented in same manner as a `WorkerPool` and allows to specify number of workers that going to proseed values received from the incoming channel. Outgoing channel is going to be closed once the incoming chan is closed or context canceld.

### func PipelineWithDone

```go
func PipelineWithDone[T any](done <-chan struct{}, incoming <-chan T, totalWorkers int, workerFn func(T) T) <-chan T
```

PipelineWithDone returns the channel of generic type `T` that can serve as a pipeline for the next stage. It's implemented in same manner as a `WorkerPool` and allows to specify number of workers that going to proseed values received from the incoming channel. Outgoing channel is going to be closed once the incoming chan is closed or context canceld.

### func QueueWithContext

```go
func QueueWithContext[T any](ctx context.Context, genFn func() T) <-chan T
```

QueueWithContext returns an unbuffered channel that is populated by func `genFn`. Chan is closed once context is Done. It's similar to `Future` pattern, but doesn't have a limit to just one result.

### func QueueWithDone

```go
func QueueWithDone[T any](done <-chan struct{}, genFn func() T) <-chan T
```

QueueWithDone returns an unbuffered channel that is populated by func `genFn`. Chan is closed once context is Done. It's similar to `Future` pattern, but doesn't have a limit to just one result.

### func TeeWithContext

```go
func TeeWithContext[T any](ctx context.Context, incoming <-chan T) (<-chan T, <-chan T)
```

TeeWithContext will return two channels of generic type `T` used to fan
-out data from the incoming channel. Channels needs to be read in order next iteration over incoming chanel happen.

### func TeeWithDone

```go
func TeeWithDone[T any](done <-chan struct{}, incoming <-chan T) (<-chan T, <-chan T)
```

TeeWithDone will return two channels of generic type `T` used to fan
-out data from the incoming channel. Channels needs to be read in order next iteration over incoming chanel happen.

### func WorkerPoolWithContext

```go
func WorkerPoolWithContext[T any](ctx context.Context, totalWorkers int, workerFn func(T)) chan<- T
```

WorkerPoolWithContext returns channel of generic type `T` which excepts jobs of the same type for some number of workers that do workerFn. If you want to stop WorkerPool, close the jobQueue channel or cancel the context.

### func WorkerPoolWithDone

```go
func WorkerPoolWithDone[T any](done <-chan struct{}, totalWorkers int, workerFn func(T)) chan<- T
```

WorkerPoolWithDone returns channel of generic type `T` which excepts jobs of the same type for some number of workers that do workerFn. If you want to stop WorkerPool, close the jobQueue channel or cancel the context.

<!-- End --->
<!-- You can Edit Content under this comment --->

## Resources

* `talk` [Bryan C. Mills - Rethinking Classical Concurrency Patterns](https://www.youtube.com/watch?v=5zXAHh5tJqQ) + [`slides`](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view) + [`comments+notes`](https://github.com/sourcegraph/gophercon-2018-liveblog/issues/35)
* `book` [Katherine Cox-Buday - Concurrency In Go](https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/)
* `talk` [Rob Pike - Concurrency is not Parallelism](https://www.youtube.com/watch?v=oV9rvDllKEg) + [`slides`](https://go.dev/talks/2012/waza.slide)
* `blog` [Go Concurrency Patterns: Context](https://go.dev/blog/context)
* `blog` [Go Concurrency Patterns: Pipelines and cancellation](https://go.dev/blog/pipelines)
* `talk` [Sameer Ajmani  - Advanced Go Concurrency Patterns](https://www.youtube.com/watch?v=QDDwwePbDtw) + [`slides`](https://talks.golang.org/2013/advconc.slide)
* `talk` [Rob Pike - Go Concurrency Patterns](https://www.youtube.com/watch?v=f6kdp27TYZs) + [`slides`](https://talks.golang.org/2012/concurrency.slide)
* `blog` [Go Concurrency Patterns: Timing out, moving on](https://go.dev/blog/concurrency-timeouts)
